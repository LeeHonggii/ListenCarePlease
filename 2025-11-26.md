# 진행 과정
- 주석 처리 기초 결과물 출력

# Test 방식
## 1차
- **오타 및 문맥 수정 (1번):**
    - 기존 로직(`original` → `corrected`)을 유지하되, **프롬프트에 "문맥 교정"을 더 강조**합니다.
- **중복 주석 병합 (2번):**
    - **LLM에게:** "포함 관계(PII vs PII 마스킹)나 유의어(군집화 vs 클러스터링)가 있으면 **더 포괄적이거나 긴 단어 하나만** 뽑아라"고 강력히 지시합니다.
    - **Python에게:** **긴 단어부터 먼저 교체(Longest Match First)**하게 하여, 'PII 마스킹'이 처리되면 'PII'는 처리되지 않도록(혹은 원문에 없도록) 만듭니다.
- **원문 표시 vs 해설 표시 분리 (3번):**
    - JSON 구조를 쪼갭니다.
        - `replace_word`: 원문에 표시할 짧고 깔끔한 단어 (예: **익명화**)
        - `glossary_word`: 해설집에 넣을 상세 단어 (예: **익명화 (anonymization)**)

## 2차
- **중복 원천 차단 (Python Level):** LLM이 "클러스터링"을 3번 뱉더라도, 파이썬 코드에서 **`set` 자료구조**를 사용하여 강제로 중복을 제거하고 하나만 남깁니다.
- **표기 분리 (Clean Split):** `replace_word`(익명화)와 `glossary_word`(익명화 (anonymization))를 철저히 구분하여, **원문에는 깔끔한 단어만**, **해설에는 상세한 단어**가 들어가게 합니다.
- **오타 수정 기능 제거:** 과도한 수정으로 정상 단어까지 건드리는 것을 막기 위해, 오타 수정 지시를 빼고 **"있는 그대로 추출하되, 설명만 잘 달아라"**로 변경합니다.
- **역방향 인덱싱:** 중복 단어가 제거된 최종 리스트를 기준으로 번호를 다시 매겨서, `(7)군집화`, `(14)군집화` 같은 참사를 막습니다.

## 3차
- **중복 삭제:** `seen_words` 집합(Set)을 사용해, `target_word`가 같은 항목은 무조건 리스트에서 제외합니다. 이제 `(7)군집화`, `(14)군집화` 같은 현상은 절대 발생하지 않습니다.
- **깔끔한 원문:** `replace` 시 `replacement = f"({idx}){target}"` 방식을 사용하여, 뒤에 영어 설명(`(analysis)`)이 붙지 않고 **`(5)익명화`** 형태로만 깔끔하게 바뀝니다.
- **오타 수정 중단:** 프롬프트에서 `Correction` 지시를 삭제하고 `Exact Match`를 강조하여, 원문에 있는 단어를 맘대로 바꾸지 않도록 했습니다.
- **해설은 상세하게:** 하단 해설 섹션에서는 `glossary_term`을 사용하여 **`(5) 익명화 (Anonymization)`** 처럼 자세한 정보를 보여줍니다.

## 4차
- **오타 교체:** 원문에 "파인트닝"이 있었다면, 결과 파일에서는 **"(1)파인튜닝"**으로 바뀝니다.
- **깔끔한 표기:** "익명화 (analysis)" 같은 긴 영어 표기가 본문에 붙지 않고, 깔끔하게 **"(5)익명화"**로만 나옵니다.
- **중복 제거:** 뜻이 같은 단어들은 하나로 합쳐져서 한 번만 등장합니다.
- **1회 표시:** 문서 전체에서 최초 등장 시에만 주석이 붙습니다.

## 5차
- **그룹화 (Grouping):** LLM에게 **"유사 단어/오타를 하나의 그룹으로 묶어라"**고 시켜서, `synonyms` 리스트를 받아냅니다. (예: `["군집화", "클러스터링", "클러스터링(오타)"]` → 이 그룹은 하나로 취급)
- **순서 정렬 (Sequential Indexing):** 텍스트 맨 앞에서부터 단어가 등장하는 위치(`index`)를 찾아서, **가장 빨리 등장하는 단어 순서대로** 번호(1, 2, 3...)를 매깁니다.
- **깔끔한 치환 (Clean Replacement):** 본문에는 영어 설명 없이 **`clean_word`*만 넣습니다.
- **강제 카운팅 (Max 20):** 모든 정리가 끝난 리스트를 앞에서부터 딱 20개만 자릅니다.

## 6차
- **원문에 (번역) 제거:** 파이썬 정규표현식(`re`)으로 본문 교체용 단어에서 **괄호와 그 안의 내용을 강제 삭제**합니다. 무조건 `(1)단어`로만 나옵니다.
- **완벽한 중복 제거:** `단어`와 `단어(영어)`를 같은 것으로 간주하는 **정규화(Normalization) 로직**을 추가하여, 띄어쓰기나 괄호 유무가 달라도 무조건 하나로 합칩니다.
- **문맥 불명 제외:** 프롬프트에 **"Negative Constraint"**를 최우선 순위로 배치하여, 뜻이 모호한 단어는 아예 뽑지 않도록 합니다.
- **해설 표기 정제:** `glossary_word` 생성 시, LLM에게 "오타 수정 내역을 적지 마라"고 강력히 지시합니다.
- **완벽한 인덱스 순서:** LLM이 준 순서를 무시하고, 파이썬이 **원문 전체를 스캔하여 "가장 먼저 등장한 단어"를 1번으로 강제 재정렬**합니다.

# 발생 문제
- 주석 index(1, 2)가 문서에서의 등장 순서와 연관 없이 랜덤하게 생성
- STT → 음성 인식 등 원문 단어 교체
- 원문 단어에 index 추가 시, 앞/뒤 단어 삭제되는 현상
- 같은 단어/하위 단어가 중복 주석 처리 되는 현상((17)코리안 PII 마스킹, (18)PII 등)
- 원문에도 번역이 들어가는 현상((15)STT (음성 인식) 등)
- 중요도 판단 불가로 무조건적인 20개의 단어를 뽑는 현상
- LLM조차 뜻을 파악하지 못하는 단어를 추출 후 모른다고 추가하는 것
- 같은 단어가 중복적으로 몇개씩 출력되는 현상
- 추출 단어의 앞/뒤 단어까지 추출하는 현상(LLM에서 : 뜻 등)

## 진행 예정
- 현재 발생 문제들의 처리는 고도화 작업으로 변경
    - 위의 문제 해결에 과도한 시간 투자는 낭비라고 판단
    - 우선 결과 형태 공유가 중요
- LangChain 방식 탐구 및 변경 시도